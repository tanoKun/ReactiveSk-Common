<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/adapter-common/src/main/kotlin/com/github/tanokun/reactivesk/skriptadapter/common/dynamic/PluginDynamicManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/adapter-common/src/main/kotlin/com/github/tanokun/reactivesk/skriptadapter/common/dynamic/PluginDynamicManager.kt" />
              <option name="originalContent" value="package com.github.tanokun.reactivesk.skriptadapter.common.dynamic&#10;&#10;import com.github.tanokun.reactivesk.compiler.backend.codegen.JvmBytecodeGenerator&#10;import com.github.tanokun.reactivesk.lang.Identifier&#10;import com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader.DynamicClassLoader&#10;import com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader.PluginDynamicClassDefinitionLoader&#10;import java.io.File&#10;&#10;class PluginDynamicManager&lt;T&gt;(private val scriptRootFolder: File, private val jvmBytecodeGenerator: JvmBytecodeGenerator&lt;T&gt;) {&#10;    private var currentClassLoader: DynamicClassLoader? = null&#10;    private var loadedClasses: Map&lt;Identifier, Class&lt;T&gt;&gt; = emptyMap()&#10;    val definitionLoader = PluginDynamicClassDefinitionLoader()&#10;&#10;    fun initialize() {&#10;        this.loadedClasses = performFullLoad()&#10;    }&#10;&#10;    /**&#10;     * 変更を検出して再読み込みを行い、差分を返します。&#10;     *&#10;     * @return 検出された変更差分のリスト&#10;     */&#10;    fun reload(): List&lt;ChangedDifference&gt; {&#10;        val oldClasses = this.loadedClasses&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;    private fun performFullLoad(): Map&lt;Identifier, Class&lt;T&gt;&gt; {&#10;        definitionLoader.loadAllClassesFrom(scriptRootFolder)&#10;&#10;        val allDefinitions = definitionLoader.getAllDefinitions()&#10;&#10;        val unloadedTypes = allDefinitions.map { definition -&gt;&#10;            jvmBytecodeGenerator.generateClass(definition)&#10;        }&#10;&#10;        val newClassLoader = DynamicClassLoader(this.javaClass.classLoader, unloadedTypes)&#10;        this.currentClassLoader = newClassLoader&#10;&#10;        return unloadedTypes.associate { unloadedType -&gt;&#10;            val loadedClass = newClassLoader.loadClass(unloadedType.typeDescription.name) as Class&lt;T&gt;&#10;            Identifier(loadedClass.simpleName) to loadedClass&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 指定した型名に対応する読み込まれたクラスを返します。&#10;     *&#10;     * @param typeName 検索する型名を表す [Identifier]&#10;     *&#10;     * @return 見つかった場合は対応する `Class&lt;T&gt;`、見つからない場合は null&#10;     */&#10;    fun getLoadedClass(typeName: Identifier): Class&lt;T&gt;? {&#10;        return loadedClasses[typeName]&#10;    }&#10;&#10;    private fun calculateDifferences(oldMap: Map&lt;Identifier, Class&lt;*&gt;&gt;, newMap: Map&lt;Identifier, Class&lt;T&gt;&gt;): List&lt;ChangedDifference&gt; {&#10;                newClass != null &amp;&amp; oldClass == null -&gt; ChangedDifference.Added(key, newClass)&#10;                oldClass != null &amp;&amp; newClass == null -&gt; ChangedDifference.Removed(key, oldClass)&#10;                newClass != null &amp;&amp; oldClass != null -&gt; ChangedDifference.Changed(key, oldClass, newClass)&#10;                else -&gt; null&#10;            }&#10;            changedDifference?.let { changedDifferences.add(it) }&#10;        }&#10;        return changedDifferences&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.github.tanokun.reactivesk.skriptadapter.common.dynamic&#13;&#10;&#13;&#10;import com.github.tanokun.reactivesk.compiler.backend.codegen.JvmBytecodeGenerator&#13;&#10;import com.github.tanokun.reactivesk.lang.Identifier&#13;&#10;import com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader.DynamicClassLoader&#13;&#10;import com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader.PluginDynamicClassDefinitionLoader&#13;&#10;import java.io.File&#13;&#10;&#13;&#10;/**&#13;&#10; * プラグイン動的管理を行うクラスです。&#13;&#10; * スクリプトフォルダからクラス定義を読み込み、JVM バイトコードを生成して動的に読み込みます。&#13;&#10; *&#13;&#10; * @param scriptRootFolder クラス定義を検索するスクリプトのルートフォルダ&#13;&#10; * @param jvmBytecodeGenerator バイトコードを生成するためのジェネレータ&#13;&#10; */&#13;&#10;class PluginDynamicManager&lt;T&gt;(private val scriptRootFolder: File, private val jvmBytecodeGenerator: JvmBytecodeGenerator&lt;T&gt;) {&#13;&#10;    private var currentClassLoader: DynamicClassLoader? = null&#13;&#10;    private var loadedClasses: Map&lt;Identifier, Class&lt;T&gt;&gt; = emptyMap()&#13;&#10;    val definitionLoader = PluginDynamicClassDefinitionLoader()&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 初期化を行い、すべてのクラスを読み込みます。&#13;&#10;     */&#13;&#10;    fun initialize() {&#13;&#10;        this.loadedClasses = performFullLoad()&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 変更を検出して再読み込みを行い、差分を返します。&#13;&#10;     *&#13;&#10;     * @return 検出された変更差分のリスト&#13;&#10;     */&#13;&#10;    fun reload(): List&lt;ChangedDifference&gt; {&#13;&#10;        val oldClasses = this.loadedClasses&#13;&#10;        val newClasses = performFullLoad()&#13;&#10;        this.loadedClasses = newClasses&#13;&#10;        return calculateDifferences(oldClasses, newClasses)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;    private fun performFullLoad(): Map&lt;Identifier, Class&lt;T&gt;&gt; {&#13;&#10;        definitionLoader.loadAllClassesFrom(scriptRootFolder)&#13;&#10;&#13;&#10;        val allDefinitions = definitionLoader.getAllDefinitions()&#13;&#10;&#13;&#10;        val unloadedTypes = allDefinitions.map { definition -&gt;&#13;&#10;            jvmBytecodeGenerator.generateClass(definition)&#13;&#10;        }&#13;&#10;&#13;&#10;        val newClassLoader = DynamicClassLoader(this.javaClass.classLoader, unloadedTypes)&#13;&#10;        this.currentClassLoader = newClassLoader&#13;&#10;&#13;&#10;        return unloadedTypes.associate { unloadedType -&gt;&#13;&#10;            val loadedClass = newClassLoader.loadClass(unloadedType.typeDescription.name) as Class&lt;T&gt;&#13;&#10;            Identifier(loadedClass.simpleName) to loadedClass&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 指定した型名に対応する読み込まれたクラスを返します。&#13;&#10;     *&#13;&#10;     * @param typeName 検索する型名を表す [Identifier]&#13;&#10;     *&#13;&#10;     * @return 見つかった場合は対応する `Class&lt;T&gt;`、見つからない場合は null&#13;&#10;     */&#13;&#10;    fun getLoadedClass(typeName: Identifier): Class&lt;T&gt;? {&#13;&#10;        return loadedClasses[typeName]&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun calculateDifferences(oldMap: Map&lt;Identifier, Class&lt;*&gt;&gt;, newMap: Map&lt;Identifier, Class&lt;T&gt;&gt;): List&lt;ChangedDifference&gt; {&#13;&#10;        val changedDifferences = mutableListOf&lt;ChangedDifference&gt;()&#13;&#10;        val allKeys = oldMap.keys union newMap.keys&#13;&#10;&#13;&#10;        for (key in allKeys) {&#13;&#10;            val oldClass = oldMap[key]&#13;&#10;            val newClass = newMap[key]&#13;&#10;            val changedDifference = when {&#13;&#10;                newClass != null &amp;&amp; oldClass == null -&gt; ChangedDifference.Added(key, newClass)&#13;&#10;                oldClass != null &amp;&amp; newClass == null -&gt; ChangedDifference.Removed(key, oldClass)&#13;&#10;                newClass != null &amp;&amp; oldClass != null -&gt; ChangedDifference.Changed(key, oldClass, newClass)&#13;&#10;                else -&gt; null&#13;&#10;            }&#13;&#10;            changedDifference?.let { changedDifferences.add(it) }&#13;&#10;        }&#13;&#10;        return changedDifferences&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/adapter-common/src/main/kotlin/com/github/tanokun/reactivesk/skriptadapter/common/dynamic/classloader/PluginDynamicClassDefinitionLoader.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/adapter-common/src/main/kotlin/com/github/tanokun/reactivesk/skriptadapter/common/dynamic/classloader/PluginDynamicClassDefinitionLoader.kt" />
              <option name="originalContent" value="package com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader&#10;&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.DynamicClassDefinitionIndentLexer&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.DynamicClassDefinitionVisitor&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.antlr.DynamicClassDefinitionParser&#10;import com.github.tanokun.reactivesk.lang.ClassDefinition&#10;import com.github.tanokun.reactivesk.lang.Identifier&#10;import org.antlr.v4.runtime.CharStreams&#10;import org.antlr.v4.runtime.CommonTokenStream&#10;import java.io.File&#10;&#10;class PluginDynamicClassDefinitionLoader {&#10;    private val definitions = mutableMapOf&lt;Identifier, ClassDefinition&gt;()&#10;&#10;    fun loadAllClassesFrom(folder: File) {&#10;        clear()&#10;        folder.walkTopDown().filter { it.isFile &amp;&amp; it.extension == &quot;sk&quot; }.forEach { file -&gt;&#10;            try {&#10;                parseAndCacheFile(file)&#10;            } catch (e: Exception) {&#10;                System.err.println(&quot;Failed to parse file ${file.name}: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun parseAndCacheFile(file: File) {&#10;        val definitionsInFile = parseSingleFile(file)&#10;        definitionsInFile.forEach { def -&gt;&#10;            if (definitions.containsKey(def.className)) {&#10;                System.err.println(&quot;Warning: Duplicate class definition for '${def.className}'. The definition from '${file.name}' will be used.&quot;)&#10;            }&#10;&#10;            definitions[def.className] = def&#10;        }&#10;    }&#10;&#10;    fun getAllDefinitions(): List&lt;ClassDefinition&gt; {&#10;        return definitions.values.toList()&#10;    }&#10;&#10;    fun getClassDefinition(className: Identifier): ClassDefinition? = definitions[className]&#10;&#10;    private fun parseSingleFile(file: File): List&lt;ClassDefinition&gt; {&#10;        val input = CharStreams.fromPath(file.toPath())&#10;        val lexer = DynamicClassDefinitionIndentLexer(input)&#10;        val tokens = CommonTokenStream(lexer)&#10;        val parser = DynamicClassDefinitionParser(tokens)&#10;        val visitor = DynamicClassDefinitionVisitor()&#10;&#10;        return visitor.visitProgram(parser.program())&#10;    }&#10;&#10;    private fun clear() {&#10;        definitions.clear()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.github.tanokun.reactivesk.skriptadapter.common.dynamic.classloader&#13;&#10;&#13;&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.DynamicClassDefinitionIndentLexer&#13;&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.DynamicClassDefinitionVisitor&#13;&#10;import com.github.tanokun.reactivesk.compiler.frontend.parser.antlr.DynamicClassDefinitionParser&#13;&#10;import com.github.tanokun.reactivesk.lang.ClassDefinition&#13;&#10;import com.github.tanokun.reactivesk.lang.Identifier&#13;&#10;import org.antlr.v4.runtime.CharStreams&#13;&#10;import org.antlr.v4.runtime.CommonTokenStream&#13;&#10;import java.io.File&#13;&#10;&#13;&#10;/**&#13;&#10; * プラグイン用の動的クラス定義ローダーです。&#13;&#10; * 指定フォルダ内のスクリプトファイルを解析してクラス定義をキャッシュします。&#13;&#10; *&#13;&#10; * @property definitions キャッシュされたクラス定義のマップ&#13;&#10; */&#13;&#10;class PluginDynamicClassDefinitionLoader {&#13;&#10;    private val definitions = mutableMapOf&lt;Identifier, ClassDefinition&gt;()&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 指定フォルダ配下のすべての &quot;.sk&quot; ファイルを読み込み解析して定義をキャッシュします。&#13;&#10;     *&#13;&#10;     * @param folder 検索対象のフォルダ&#13;&#10;     *&#13;&#10;     * @return なし&#13;&#10;     */&#13;&#10;    fun loadAllClassesFrom(folder: File) {&#13;&#10;        clear()&#13;&#10;        folder.walkTopDown().filter { it.isFile &amp;&amp; it.extension == &quot;sk&quot; }.forEach { file -&gt;&#13;&#10;            try {&#13;&#10;                parseAndCacheFile(file)&#13;&#10;            } catch (e: Exception) {&#13;&#10;                System.err.println(&quot;Failed to parse file ${file.name}: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 解析結果をキャッシュに追加します。既に同名の定義が存在する場合は上書きします。&#13;&#10;     *&#13;&#10;     * @param file 解析対象のファイル&#13;&#10;     *&#13;&#10;     * @return なし&#13;&#10;     */&#13;&#10;    private fun parseAndCacheFile(file: File) {&#13;&#10;        val definitionsInFile = parseSingleFile(file)&#13;&#10;        definitionsInFile.forEach { def -&gt;&#13;&#10;            if (definitions.containsKey(def.className)) {&#13;&#10;                System.err.println(&quot;Warning: Duplicate class definition for '${def.className}'. The definition from '${file.name}' will be used.&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            definitions[def.className] = def&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * キャッシュされているすべてのクラス定義をリストで返します。&#13;&#10;     *&#13;&#10;     * @return キャッシュされている `List&lt;ClassDefinition&gt;`&#13;&#10;     */&#13;&#10;    fun getAllDefinitions(): List&lt;ClassDefinition&gt; {&#13;&#10;        return definitions.values.toList()&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 指定したクラス名に対応するクラス定義を返します。&#13;&#10;     *&#13;&#10;     * @param className 検索するクラス名を表す [Identifier]&#13;&#10;     *&#13;&#10;     * @return 見つかった場合は対応する `ClassDefinition`、見つからない場合は null&#13;&#10;     */&#13;&#10;    fun getClassDefinition(className: Identifier): ClassDefinition? = definitions[className]&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 単一ファイルを解析してそのファイル内のクラス定義一覧を返します。&#13;&#10;     *&#13;&#10;     * @param file 解析対象のファイル&#13;&#10;     *&#13;&#10;     * @return ファイル内に含まれる `List&lt;ClassDefinition&gt;`&#13;&#10;     */&#13;&#10;    private fun parseSingleFile(file: File): List&lt;ClassDefinition&gt; {&#13;&#10;        val input = CharStreams.fromPath(file.toPath())&#13;&#10;        val lexer = DynamicClassDefinitionIndentLexer(input)&#13;&#10;        val tokens = CommonTokenStream(lexer)&#13;&#10;        val parser = DynamicClassDefinitionParser(tokens)&#13;&#10;        val visitor = DynamicClassDefinitionVisitor()&#13;&#10;&#13;&#10;        return visitor.visitProgram(parser.program())&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * キャッシュをクリアします。&#13;&#10;     *&#13;&#10;     * @return なし&#13;&#10;     */&#13;&#10;    private fun clear() {&#13;&#10;        definitions.clear()&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>